<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ title or app_name }}</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css"
    />
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}" />
    <style>
      body {
        min-height: 100vh;
        background: linear-gradient(135deg, #f8fbff 0%, #eef5ff 100%);
      }
      .sidebar {
        background: #0f1f3d;
        color: #fff;
        min-height: 100vh;
        padding: 2rem 1.5rem;
      }
      .sidebar a {
        color: rgba(255, 255, 255, 0.8);
      }
      .sidebar a.is-active {
        color: #fff;
        font-weight: 600;
      }
      .pill {
        border-radius: 999px;
        padding: 0.1rem 0.9rem;
        font-weight: 600;
        font-size: 0.85rem;
      }
      .card + .card {
        margin-top: 1.5rem;
      }
      pre.config-json {
        background: #0f1f3d;
        color: #e5efff;
        padding: 1rem;
        border-radius: 0.75rem;
        max-height: 400px;
        overflow: auto;
      }
      
      /* System Console */
      .system-console {
        position: fixed;
        bottom: 0;
        left: 16.6667%; /* Match sidebar width (column is-2) */
        right: 0;
        background: #fff;
        border-top: 1px solid #dbdbdb;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
        z-index: 1000;
        transition: transform 0.3s ease;
        transform: translateY(calc(100% - 40px)); /* Collapsed state */
      }
      .system-console.is-open {
        transform: translateY(0);
      }
      .console-header {
        height: 40px;
        background: #f5f5f5;
        padding: 0 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        border-bottom: 1px solid #dbdbdb;
      }
      .console-header:hover {
        background: #ededed;
      }
      .console-body {
        height: 250px;
        padding: 1rem;
        display: flex;
        flex-direction: column;
      }
      .console-logs {
        flex: 1;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.8rem;
        background: #0f1f3d;
        color: #e5efff;
        padding: 0.5rem;
        border-radius: 4px;
      }
      .console-logs p {
        margin-bottom: 2px;
        line-height: 1.4;
      }
      .log-time { color: #666; margin-right: 8px; }
      .log-info { color: #e5efff; }
      .log-success { color: #48c774; }
      .log-warning { color: #ffdd57; }
      .log-error { color: #f14668; }
      .log-pipeline { color: #3298dc; }
    </style>
  </head>
  <body>
    <div class="columns is-gapless mb-0">
      <aside class="column is-2 sidebar">
        <div class="mb-5">
          <p class="title is-4 has-text-white">{{ app_name }}</p>
          <p class="subtitle is-7 has-text-grey-light">Bluecrest News Radar</p>
        </div>
        <nav class="menu">
          <ul class="menu-list">
            {% for link in nav_links %}
            <li>
              <a
                href="{{ url_for(link.endpoint) }}"
                class="{% if active_page == link.endpoint %}is-active{% endif %}"
              >
                <span class="icon">
                  <i class="mdi {{ link.icon }}"></i>
                </span>
                <span>{{ link.label }}</span>
              </a>
            </li>
            {% endfor %}
          </ul>
        </nav>
      </aside>
      <main class="column is-10 p-6" style="margin-bottom: 40px;">
        <div class="mb-5">
          <h1 class="title">{{ page_title or title or app_name }}</h1>
          {% if page_subtitle %}
          <p class="subtitle">{{ page_subtitle }}</p>
          {% endif %}
        </div>
        {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
        <div class="mb-4">
          {% for category, message in messages %}
          <div class="notification is-{{ category }} is-light">
            {{ message }}
          </div>
          {% endfor %}
        </div>
        {% endif %}
        {% endwith %}
        {% block content %}{% endblock %}
      </main>
    </div>

    <!-- Global System Console -->
    <div id="system-console" class="system-console">
      <div class="console-header" onclick="SystemConsole.toggle()">
        <div class="level is-mobile is-flex-grow-1">
            <div class="level-left">
                <span class="icon mr-2"><i class="mdi mdi-console"></i></span>
                <span class="has-text-weight-semibold">System Console</span>
                <span id="console-status" class="tag is-light ml-3 is-hidden">Idle</span>
            </div>
            <div class="level-right">
                <span class="icon transition-icon" id="console-chevron"><i class="mdi mdi-chevron-up"></i></span>
            </div>
        </div>
      </div>
      <div class="console-body">
        <div class="level is-mobile mb-2">
            <div class="level-left">
                <button id="console-run-btn" class="button is-small is-primary" onclick="event.stopPropagation(); SystemConsole.runPipeline()">
                    <span class="icon is-small"><i class="mdi mdi-play"></i></span>
                    <span>Run Pipeline</span>
                </button>
                <button class="button is-small is-text ml-2" onclick="event.stopPropagation(); SystemConsole.clear()">
                    Clear Logs
                </button>
            </div>
            <div class="level-right">
                <label class="checkbox is-size-7">
                    <input type="checkbox" id="auto-scroll" checked onclick="event.stopPropagation()"> Auto-scroll
                </label>
            </div>
        </div>
        <progress id="console-progress" class="progress is-small is-primary mb-2 is-hidden" value="0" max="100"></progress>
        <div id="console-logs" class="console-logs">
            <p class="has-text-grey">System ready.</p>
        </div>
      </div>
    </div>

    <script>
      const SystemConsole = {
        isOpen: false,
        isRunning: false,
        el: document.getElementById('system-console'),
        logsEl: document.getElementById('console-logs'),
        progressEl: document.getElementById('console-progress'),
        btnEl: document.getElementById('console-run-btn'),
        chevronEl: document.getElementById('console-chevron'),
        statusEl: document.getElementById('console-status'),
        currentOffset: 0,
        isLoadingHistory: false,
        
        toggle: function() {
            this.isOpen = !this.isOpen;
            if (this.isOpen) {
                this.el.classList.add('is-open');
                this.chevronEl.innerHTML = '<i class="mdi mdi-chevron-down"></i>';
                // Scroll to bottom on open if near bottom, or just let it be
                if (this.currentOffset === 0) {
                     this.logsEl.scrollTop = this.logsEl.scrollHeight;
                }
            } else {
                this.el.classList.remove('is-open');
                this.chevronEl.innerHTML = '<i class="mdi mdi-chevron-up"></i>';
            }
        },

        open: function() {
            if (!this.isOpen) this.toggle();
        },

        clear: function() {
            this.logsEl.innerHTML = '';
            this.currentOffset = 0;
            this.log('Logs cleared.', 'info');
        },

        log: function(msg, type='info', details=null) {
            const line = this.createLogLine(msg, type, Date.now() / 1000);
            this.logsEl.appendChild(line);
            
            if (document.getElementById('auto-scroll').checked) {
                this.logsEl.scrollTop = this.logsEl.scrollHeight;
            }
        },
        
        createLogLine: function(msg, type, timestamp) {
            const line = document.createElement('p');
            const time = new Date(timestamp * 1000).toLocaleTimeString();
            let colorClass = `log-${type}`;
            // Map legacy types if needed
            if (!['info', 'success', 'warning', 'error', 'pipeline'].includes(type)) {
                colorClass = 'log-info';
            }
            
            line.innerHTML = `<span class="log-time" style="opacity:0.6">[${time}]</span> <span class="${colorClass}">${msg}</span>`;
            return line;
        },

        runPipeline: async function() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.open();
            this.btnEl.classList.add('is-loading');
            this.btnEl.disabled = true;
            this.progressEl.classList.remove('is-hidden');
            this.progressEl.value = 0;
            this.statusEl.classList.remove('is-hidden');
            this.statusEl.innerText = "Running...";
            
            this.log('Starting pipeline run...', 'pipeline');

            try {
                // 1. Warmup
                this.log('Warming up AI models...', 'info');
                try {
                    const wResp = await fetch("{{ url_for('api_pipeline_warmup') }}", {method: 'POST'});
                    const wData = await wResp.json();
                    if (wData.status === 'success') this.log('AI models ready.', 'success');
                    else this.log('Warmup warning: ' + wData.message, 'warning');
                } catch (e) {
                    this.log('Warmup skipped (network): ' + e.message, 'warning');
                }

                // 2. Fetch
                this.log('Fetching articles...', 'info');
                const fResp = await fetch("{{ url_for('api_pipeline_fetch') }}", {method: 'POST'});
                const fData = await fResp.json();
                
                if (fData.status === 'error') throw new Error(fData.message);
                
                const articles = fData.articles || [];
                this.log(`Found ${articles.length} articles.`, 'info');
                
                if (articles.length === 0) {
                    this.log('No new articles to process.', 'warning');
                } else {
                    // 3. Process Loop
                    let processed = 0;
                    for (const article of articles) {
                        this.statusEl.innerText = `Processing ${processed+1}/${articles.length}`;
                        this.log(`Analyzing: ${article.title.substring(0, 50)}...`, 'info');
                        
                        try {
                            const pResp = await fetch("{{ url_for('api_pipeline_process') }}", {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify(article)
                            });
                            const res = await pResp.json();
                            
                            if (res.status === 'imported') {
                                this.log(`Imported: ${article.title}`, 'success');
                                if (res.alert) this.log('!!! ALERT TRIGGERED !!!', 'error');
                            } else if (res.status === 'skipped') {
                                this.log(`Skipped: ${article.title} (${res.reason})`, 'warning');
                            }
                        } catch (err) {
                            this.log(`Error processing ${article.title}: ${err.message}`, 'error');
                        }
                        
                        processed++;
                        this.progressEl.value = (processed / articles.length) * 100;
                    }
                    
                    // 4. Complete
                    await fetch("{{ url_for('api_pipeline_complete') }}", {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({count: processed})
                    });
                }

                this.log('Pipeline run complete.', 'success');
                this.statusEl.innerText = "Complete";
                
                // Refresh page after short delay to show new data
                setTimeout(() => location.reload(), 1500);

            } catch (e) {
                this.log(`Pipeline failed: ${e.message}`, 'error');
                this.statusEl.innerText = "Error";
            } finally {
                this.isRunning = false;
                this.btnEl.classList.remove('is-loading');
                this.btnEl.disabled = false;
                setTimeout(() => {
                    this.progressEl.classList.add('is-hidden');
                    this.statusEl.classList.add('is-hidden');
                }, 3000);
            }
        },
        
        loadHistory: async function() {
            if (this.isLoadingHistory) return;
            this.isLoadingHistory = true;
            
            // If offset is 0, we are loading initial history, likely clear container first?
            // But we might have real-time logs already.
            // Let's assume offset=0 is called on init.
            
            const limit = 20;
            try {
                const resp = await fetch(`{{ url_for('api_events') }}?limit=${limit}&offset=${this.currentOffset}`);
                const events = await resp.json();
                
                if (!events || events.length === 0) {
                    this.isLoadingHistory = false;
                    return;
                }

                // API returns [Newest, ..., Oldest] in that slice
                // We want to display them chronologically.
                // If scrolling up (prepending), we want the batch to be inserted at top.
                // The batch itself needs to be ordered Oldest -> Newest.
                const fragment = document.createDocumentFragment();
                
                // events is [Newest -> Oldest]
                // reverse to [Oldest -> Newest] for display order
                events.slice().reverse().forEach(e => {
                    const line = this.createLogLine(e.message, e.level === 'pipeline' ? 'pipeline' : e.level, e.timestamp);
                    fragment.appendChild(line);
                });

                const oldScrollHeight = this.logsEl.scrollHeight;
                const wasAtTop = this.logsEl.scrollTop === 0;

                if (this.currentOffset === 0) {
                    // Initial load: append to whatever "System ready" msg might be there
                    // or just prepend to keep real-time logs at bottom?
                    // Actually, if we just loaded the page, logsEl is mostly empty.
                    // We append.
                    this.logsEl.appendChild(fragment);
                    // Scroll to bottom initially
                    this.logsEl.scrollTop = this.logsEl.scrollHeight;
                } else {
                    // Prepend
                    this.logsEl.insertBefore(fragment, this.logsEl.firstChild);
                    // Restore scroll position
                    const newScrollHeight = this.logsEl.scrollHeight;
                    this.logsEl.scrollTop = newScrollHeight - oldScrollHeight;
                }

                this.currentOffset += events.length;
                
            } catch (e) {
                console.warn("Could not load event history", e);
            } finally {
                this.isLoadingHistory = false;
            }
        }
      };

      // Scroll listener for infinite scroll
      document.getElementById('console-logs').addEventListener('scroll', function(e) {
          if (this.scrollTop === 0) {
              SystemConsole.loadHistory();
          }
      });

      // Load history on init
      document.addEventListener('DOMContentLoaded', () => {
          SystemConsole.loadHistory();
      });
    </script>
  </body>
</html>
